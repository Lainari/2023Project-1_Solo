# 파일 관리

## 파일시스템
- 파일이나 자료를 쉽게 접근할 수 있도록 보관 또는 조직하는 체제
- 파일시스템에 따라 달라지는 요소
  - 포맷할 수 있는 최대 디스크 용량
  - 한 디렉토리에 추가할 수 있는 최대 서브 디렉토리 또는 파일 개수
  - 한 파일의 최대 용량
  - I/O 연산속도
  - 에러 복원

```bash:파일시스템
1. 파일이나 자료를 쉽게 접근할 수 있도록 보관 또는 조직하는 체제를 무엇이라 하는가?
2. 파일시스템에 따라 달라지는 요소로 옳지 않은 것은?
  a. 포맷할 수 있는 최소 디스크 용량
  b. 한 디렉토리에 추가할 수 있는 최대 서브 디렉토리 또는 파일 개수
  c. 한 파일의 최소 용량
  d. cpu 연산속도
  e. 에러 복원

# 정답
# 1. 파일시스템
# 2. a(최대 디스크 용량), c(파일 최대 용량), d(I/O 연산속도)

```

## 디스크 파일 시스템 확인
`/etc/fstab` 파일 확인
> UUID=2f123123-5as41-af13-ea234215 / xfs defaults 0 0

1. UUID=...
  - 파일시스템 장치명
2. / 또는 none
  - 마운트 포인트 : 해당 장치를 어떤 디렉토리에 연결할 것인가?
    - /    : 디렉토리 마운트 포인트
      - 파일 시스템의 일부를 디렉토리로 마운트를 하는 것
    - none : 마운트 포인트를 설정하지 않는다
3. xfs, swap
  - xfs  : 대용량 파일 시스템
  - swap : 가상 메모리 파일 시스템
4. defaults
  - 일반적인 파일 시스템 마운트 옵션을 지정하는데 사용
  a. auto : 부팅 시 자동으로 마운트(<-> noauto)
  b. exec : 실행 파일이 실행 되는것을 허용(<-> noexec)
  c. suid : SetUID, SetGID 허용(<-> nosuid)
  d. rw : 읽기 쓰기 가능 (<-> ro(읽기만 가능))
  e. nouser : 관리자만 마운트 가능(<-> user(일반 계정도 마운트 가능))
  f. dev : 파일 시스템의 특별한 장치에서 character 나 block 을 interprete 하라(<-> nodev)
  g. async : 파일 시스템의 모든 I/O가 비동기적으로 수행(<-> sync)
  [다른 옵션]
  - usrquata
    - 계정 사용자의 용량 제한 설정 가능
  - grpquata
    - 그룹별 설정 가능

```bash:디스크 파일 시스템 확인
1. 디스크 파일 시스템 확인할 때 어느 파일을 확인하는가?
2. 다음 용어와 의미가 일치하지 않는 것을 고르시오
  a. UUID=... : 파일시스템 장치명
  b. / 또는 none : 마운트 포인트
  c. xfs, swap : 마운트 포인트 옵션
  d. default : 일반적인 파일 시스템 마운트 옵션을 지정
  e. auto : 부팅 시 자동으로 마운트
  f. exec : 실행 파일이 실행 되는 것을 비허용
  g. suid : SetUID 허용
  h. rw : 읽기 쓰기 가능
  i. nouser : 관리자만 마운트 가능
  j. dev : 파일 시스템의 특별한 장치에서 character나 block 을 interprete 하라
  k. async : 파일 시스템의 모든 I/O가 동기적으로 수행

# 정답
# 1. /etc/fstab
# 2. c(파일 시스템의 종류), f(실행 파일 허용), g(SetGID 도 허용), k(비동기적으로 수행)

```

## 시스템의 파일 시스템 확인
`/etc/fstab` 파일 확인 중 맨 뒤 숫자 0 0 에 해당
> UUID=2f123123-5as41-af13-ea234215 / xfs defaults 0 0

- dump
  - 0 : 덤프되지 않은 파일 시스템
  - 1 : 덤프 가능
- check
  - 0 : 부팅 시 fdisk 사용하지 않음
  - 1 : 루트 파일 시스템 - 우선 체크
  - 2 : 루트 파일 시스템 외의 파일 시스템 - 1번 이후 체크

```bash:시스템의 파일 시스템 확인
1. dump 의 값이 0 일 경우의 덤프되지 않은 파일 시스템이라는 뜻이다(O, X)
2. check 의 값이 0 일 경우의 의미는 부팅 시 fdisk를 사용한다는 뜻이다(O, X)

# 정답
# 1. O
# 2. X(사용하지 않음)

```

## 파일시스템 장치명
(관리자) `blkid`
  - 블록 디바이스의 UUID 출력
  (블록 크기 단위로 데이터를 읽고 쓰는 저장장치)
`/dev/disk/by-uuid`폴더안에 각 파티션에 대한 링크를 확인할 수 있다
`ls -l /dev/disk/by-uuid` ../../sda1
- sdal의 의미 : ssd의 첫번째 디스크의 1번 파티션
  - sd = ssd
  - hd = hdd
  - a  = 첫 번째 디스크
  - 1  = 파티션 번호
```bash:파일시스템 장치명
1. 블록 디바이스의 UUID 출력하는 명령어는?
2. ls -l /dev/disk/by-uuid 의 실행 결과로 ../../sda1 가 나왔는데 이것의 의미는?

# 정답
# 1. blkid(관리자가 실행)
# 2. sda1 = ssd 의 첫 번째 디스크의 1번 파티션

```

## 파일 시스템의 종류

### 저장장치 구성
- Partition(파티션)
  - 복잡한 관리를 위해 저장장치 공간을 세분화
  - 개별 파일 시스템의 크기 제한
  - 하나의 저장장치에 여러 개의 파일 시스템 사용 가능
  - 별도의 swap 혹은 포맷되지 않은 raw 공간으로 활용
- volume(볼륨)
  - 파일 시스템을 포함하는 개체
    - 논리적인 가상 디스크(Virtual Disk)
    - 저장장치의 일부, 전체, 여러 개의 저장장치 묶음 등으로 구성

### ext
> ext 시리즈 : 리눅스의 전통적인 파일 시스템
- extended file system (확장된 파일 시스템)

### ext2
- 최대 파일 크기 : 16GB ~ 2TB
- 최대 볼륨 크기 : 4TB  ~ 32TB
- 최대 파일 수   : 10^18
- 최대 파일 이름 : 255바이트(2^8 -1)
- 모든 파일과 디렉토리를 inode로 표현

- ex2의 각 파티션 구조
1. Disk
  - Partition 0
  - Partition 1
  - partition 2

2. File System
  - Boot Sector(파티션 0와 연결)
    - 부트 로더, 파티션 크기, 파일 시스템 종류가 저장
  - Block Group 0 ~ N

3. Block Group
- Block : 파일 시스템의 I/O 단위(HDD 는 1KB ~ 4KB를 주로 사용)
(SSD 는 다음 파일 참고 : /sys/block/sda/queue/physical_block_size)
  - Super Block
    : 블록 수 1
      - 파일 시스템의 메타 데이터
      - 마운트 정보, 블록 크기 ,총 블록 개수, 블록 그룹의 개수, inode의 개수 등
      - 손상되면 안되기 때문에 각 파티션에 반복하여 저장한다
  - GDT(Group Descriptor Table)
    : 1 블록에 1그룹 정보
      - Block Bitmap 블록 번호, inode Bitmap 블록 번호, inode Table 블록번호, 빈 블록 수, inode 수, 빈 디렉토리 수 등
      - 자신 뿐 아니라 모든 그룹에 대한 정보를 가지고 있음
      - 이 정보도 각 파티션에 동일하게 나타남
      - 블록 그룹이 총 4개로 구성되어있다면 각 블록에 슈퍼 블록이 각각 한 개씩 들어있고 GDT은 블록의 수에 따라 해당 정보를 각각 가지고 있음
      (즉, 슈퍼블록 1개, GDT가 4개씩 들어있다는 말임)
  - Block Bitmap
    : 블록 수 1
      - 각 비트마다 해당 블록이 사용 여부를 표시
      - 블록 사이즈가 4KB라면 4096 * Byte(8bit) = 32768 bit
      - 한 그룹의 최대 블록 개수는 32768개가 된다
  - inode Bitmap
    : 블록 수 1
      - inode table의 사용 여부를 비트로 표시한다
      - 블록 사이즈가 4KB라면 4096 * Byte(8bit) = 32768 bit
      - 한 그룹의 최대 블록 개수는 32768개가 된다
  - inode Table
    : 블록 수 n개
      - 각 파일마다의 inode를 저장해 둔 테이블
  - Data blocks
    : 사용자들이 저장한 파일과 디렉토리 정보 등이 저장된다

### ext3
- 파일 시스템 복원을 위한 저널링(복구 기능) 기능 추가
- 백업 없이 ext2 에서 ext3로 업그레이드 가능
- 최대 파일 크기 : 16GB ~ 2TB
- 최대 볼륨 크기 : 4TB  ~ 32TB
- 최대 파일 수   : 가변
- 최대 파일 이름 : 255바이트(2^8 -1)
- 최대 서브 디렉토리 : 31998
- 초 단위의 타임 스탬프

### ext4
- Reserved GDT 는 그룹 확장을 위한 예비 공간
- 다양한 저널링 방법을 선택 가능
- 최대 파일 크기 : 16TiB
- 최대 볼륨 크기 : 4TB ~ 1EB
- 최대 파일 수   : 40억
- 최대 파일 이름 : 256바이트(2^8)
- 대형 파일 시스템
- 하위 호완, 하위 디렉토리 64000(추가 기능), 디스크 조각모음
- 나노초 단위의 타임스탬프

### xfs
- CentOS7 부터 기본 파일 시스템
- 대용량 파일의 지원
- 64비트 시스템을 기본으로 지원하며 32 비트 시스템에선 손해임
  - 저널링, 디스크 조각 모음 제공
  - 8EB 볼륨 지원 (32 비트 시스템은 16TB)
  - ext3 대비 8배 많은 수의 inode 생성 가능
  - 포맷, 파일 삭제가 빠르다
  - 작은 파일에서는 느리다


# 파일

## inode(i-node)
`-rw-rw-r--. 1 jinseok jinseok 0 4월 15 17:30 test.txt`
- 리눅스의 대표적인 파일 시스템인 ext 계열에서 사용하는 구조
- 파일에 대한 메타데이터
  - 파일이나 디렉토리는 자신만의 inode를 가진다
- inode의 최대 수 = 해당 파일 시스템이 지원하는 최대 파일(디렉토리) 수

### mode(권한)
- 파일의 접근, 실행 등을 저장하는 16비트 플래그
1. 12 ~ 15 bit : 파일 형식
`-rw-rw-r--` 에서...
  - -: 일반 파일
  - d: 디렉토리
  - c: 문자장치. 버퍼 없이 한 글자 단위로 I/O가 처리 됨 (터미널, 시리얼 포트)
  - b: 블록장치. 블록 단위로 I/O가 처리 됨(보통 디스크)
  - l: 심볼릭 링크 파일
  - p: 파이프 파일. 프로세스간의 통신
  - s: 소켓 파일. 네트워크에 사용

2. 11 bit      : SetUID, 이 파일을 실행 시 소유자의 권한을 부여
3. 10 bit      : SetGID, 이 파일을 실행 시 그룹의 권한을 부여
4. 9 bit       : Sticky bit. 디렉토리에 설정하면 누구나 파일 생성 가능. 자신의 것만 삭제 가능. /tmp
5. 8 bit       : 소유자 읽기 허가
6. 7 bit       : 소유자 쓰기 허가
7. 6 bit       : 소유자 실행 허가
8. 5 bit       : 그룹 읽기 허가
9. 4 bit       : 그룹 쓰기 허가
10. 3 bit      : 그룹 실행 허가
11. 2 bit      : 다른 사용자 읽기 허가
12. 1 bit      : 다른 사용자 쓰기 허가
13. 0 bit      : 다른 사용자 실행 허가

### 링크 수
  - 하드 링크 수

### owner(소유자)
  - 이 파일을 제작한, 또는 소유하고 있는 소유자명

### group(그룹)
  - 해당 파일의 그룹 권한을 실행할 수 있는 그룹

### size(파일 크기 - bytes)
  - 파일의 크기 표현(bytes 단위)

### 시간 정보(atime, ctime, mtime)
  - atime : access time,       접근 시간
  - ctime : inode change time, 아이노드 변경 시간
  - mtime : modification time, 수정 시간

### 파일 주소
> direct blocks(12개), indirect blocks, double indirect blocks, triple indirect blocks
- indirect block 하나 당 주소 1024개
```bash:직접 블록 예시
10KB 파일을 저장하려면?

# 정답
# 4KB 블록 2개, 2KB 블록 1개 총 직접 블록은 3개 사용

```
- 직접 블록은 12개를 사용하므로 최대 48KB까지 저장 가능

```bash:간접 블록 예시
데이터 블록 하나를 실제 값을 저장하지 않고 주소 하나당 4Byte를 가지므로
4KB를 가지는 블록 하나에 총 주소 1024개를 저장할 수 있음
결국 간접 블록 하나에는 4KB 블록을 가리키는 주소가 총 1024개 있음
4KB * 1024 = 4MB 를 저장할 수 있는 것이다!
```

### Directory는 어떻게 구성되는가?
- 별도의 inode는 없다
- mode에서 directory 임을 표시(drw-r--r-- ...)
- Data block 에서 내부 디렉토리와 내부 파일의 inode를 가리킨다

### 파일 / 디렉토리의 inode 번호 확인
```bash
stat[option] file | directory
 [option]
  없음        : 전체 정보 출력
  -t          : 간략히 출력
  -c "format" : 주어진 포맷에 맞게 출력

  -ls -li {file|directory} : 파일의 정보 또는 해당 디렉토리 내부 요소들의 정보
  -ls -ldi {directory}     : 해당 디렉토리의 정보
```


## 링크

### 심볼릭 링크
- 윈도우즈의 바로 가기와 같은 역할
- 새로운 inode를 가지는 새 파일/디렉토리가 생성 -> 원본을 가리킴

### 하드 링크
- 기존과 동일한 inode를 가지는 링크
- 파일/디렉토리가 늘지 않음
- 새로운 이름표가 생기는 것과 같은 효과
- 동일 파일 시스템에서만 만들 수 있다
- 원본 포함 모든 하드 링크를 삭제해야 원본이 삭제된다

`ln [option] original link`
`-s` 옵션으로 심볼릭 링크 생성
`-i` 옵션으로 만약 대상 파일이 이미 존재할 때 물어본다
`-b` 옵션으로 만약 대상 파일이 이미 존재하면 기존 파일을 백업한다
  - 기본 : 파일 이름 뒤에 ~ 추가
  - 환경 변수 SIMPLE_BACKUP_SUFFIX 로 설정 가능

`ls -l` 로 하드 링크의 수와 심볼릭 링크의 원본 파일 확인 가능

```bash:하드링크 ++
폴더를 만들면 빈폴더라도 하드링크가 2인데 왜 일까?

# 정답
# 본인의 링크인 . 과 상위 디렉토리 하드링킁니 .. 를 동시에 포함하고 있기 때문
```
- 디렉토리에 대한 하드링크는 기본적으로 허용되지 않는다
  - 심볼릭 링크의 경우 inode 번호가 다르기때문에 무한 루프를 피할 수 있다
  - 하드 링크의 경우 inode 번호가 같기 때문에 무한 루프에 빠질 수 있다

## 소유권과 권한
- 소유권 : 파일을 소유한 사용자와 그룹
- 권한 : 파일을 읽고(r), 쓰고(w), 실행(x)할 수 있는 권한 설정
- 단, 디렉토리의 경우 r, w, x가 다음의 의미로 처리 된다
  - r : 디렉토리 내부의 파일과 디렉토리 '이름'을 읽을 수 있다
  - w : 디렉토리 내부의 항목들을 수정할 수 있다
  - x : 디렉토리 내부 파일의 콘텐츠와 메타데이터(ls - l)에 접근할 수 있다
- 이와 같이 현재 권한 상태를 3개의 숫자로 나타낼 수 있음
`-rw-rw-r--` : 6 6 4
- r : 4
- w : 2
- x : 1

## 권한 변경
`chmod [option] [mode] file|directory`

### 옵션
`-v` 옵션으로 모든 파일에 대해 진단 메시지 출력
`-f` 옵션으로 에러 메시지 출력하지 않음
`-c` 옵션으로 변경 되는 경우에만 메시지 출력
`-R` 옵션으로 지정한 모드를 디렉토리에 대해 재귀적으로 적용

### mode
- 숫자 3개 : 664, 644와 같이 3가지 대상에 대한 설정을 숫자 3개로 표기
- u, g, o, a : 소유자 지정 문자열(a 는 all)
- +, -, = : 추가, 삭제, 적용 문자열
- r, w, x : 권한 문자열

```bash:권한 변경
1. a 파일의 권한을 사용자와 그룹에는 읽기와 쓰기만을, 나머지 사용자는 권한을 부여하지 말 것
2. a 파일의 권한을 사용자에게 실행 권한을 부여할 것
3. a 파일의 권한을 사용자와 그룹에게 실행 권한을 삭제할 것

# 정답
# 1. chmod 660 a
# 2. chmod u+x a
# 3. chmod ug-x a

```

### 특수 권한
`chmod (1|2|4) 664 a`
- 1(`u+s`) : Sticky bit, 누구나 이 파일을 생성할 수 있음
  - 단, 삭제는 본인 것만 가능하다
  - 공유 폴더의 기능이 됨 -> 최상위 디렉토리에 tmp 파일이 이 경우에 해당
- 2(`g+s`) : SetGID, 그룹이 해당 파일을 사용할 때 사용자의 권한을 일시적으로 부여해준다
- 3(`o+t`) : SetUID, 사용자가 해당 파일을 사용할 때 사용자의 권한을 일시적으로 부여해준다

```bash:특수 권한
1. file 를 SetUID 특수 권한을 부여하는 명령어를 작성하시오
2. file 를 SetGID 특수 권한을 부여하는 명령어를 작성하시오
3. directory를 Sticky bit 특수 권한을 부여하는 명령어를 작성하시오

# 정답
# 1. chmod u+s file
# 2. chmod g+s file
# 3. chmod o+t directory

```

## 소유권 변경1
`chown [option] [user] [:group] (file|directory)`
- **관리자** 가 수행, user 및 group은 숫자id로도 사용가능

### option
`-h` 옵션으로 원본 파일 대신 심볼릭 링크 파일의 소유권을 변경
`-c` 옵션으로 변경 되는 경우에만 메시지 출력
`-R` 옵션으로 지정한 모드를 디렉토리에 대해 재귀적으로 적용
```bash: 소유권 변경1
1. file1의 소요자를 user1로 변경하는 명령문을 작성하시오
2. file1의 소유 그룹을 student로 변경하는 명령문을 작성하시오
3. file1의 소유자를 user1, 그룹을 student로 변경하는 명령문을 작성하시오

# 정답
# 1. chown user1 file1
# 2. chown :student file1
# 3. chown user1:student file1

```

## 소유권 변경2
`chgrp [option] group (file|directory)`
- 본인이 소유한 파일에 대해 본인이 속한 그룹에 대해 변경 가능

### option
`-h` 옵션으로 원본 파일 대신 심볼릭 링크 파일의 소유권을 변경
`-c` 옵션으로 변경 되는 경우에만 메시지 출력
`-R` 옵션으로 지정한 모드를 디렉토리에 대해 재귀적으로 적용