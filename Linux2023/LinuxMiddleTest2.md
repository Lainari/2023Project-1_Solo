# 서버시스템 구축 - 리눅스(Linux)

# Editor(편집기)
 - gedit
    - GUI 모드에서 사용할 수 있는 기본 편집기(Notepad 역할과 동일)
    - GUI : 텍스트 편집기 실행
    - CLI : gedit [file name]

## vi(vim)
- Visual display editor(vim = Vi Improved)
- CLI 환경에서 사용하기에 좋은 편집기
```bash:vi 편집기 - 명령 모드
1. 명령 모드에서 특정 단어를 삭제하고 싶을 때의 명령어는?
2. 입력 모드에서 커서를 이동시키는 방법은 무엇인가요?
3. 명령 모드에서 현재 커서가 위치한 문자를 복사해서 다른 위치에 붙여넣기 하고 싶을 때의 명령어는?

# 정답
# 1. nx, 행 삭제시 ndd
# 2. h,j,k,l 로 이동한다
# 3. nyy로 복사하여 p 또는 P로 붙여넣기 : p는 행에 붙여넣고 P는 행 앞에 붙여넣기
```
> 명령모드에서 주로 쓰이는 키
```bash
h: 커서를 왼쪽으로 이동
j: 커서를 아래쪽으로 이동
k: 커서를 위쪽으로 이동
l: 커서를 오른쪽으로 이동
nx : 커서가 있는 글자 삭제
ndd : 커서가 있는 행 삭제
nyy : 커서가 있는 행 복사
p : 커서가 있는 행에 붙여넣기
P : 커서가 있는 행 앞에 붙여넣기
n, N : 라인 모드에서 검색 상태 일 때, n은 뒤로 검색 N은 앞으로 검색
>> , << : 현재 커서가 있는 행 들여쓰기, 앞으로 내어쓰기
```

```bash:vi 편집기 - 입력 모드
1. 명령 모드에서 현재 커서 위치에 새로운 텍스트를 삽입하고 싶을 때의 명령어는?
2. 명령 모드에서 현재 줄의 끝으로 이동하는 명령어는?
3. 명령 모드에서 현재 줄의 처음으로 이동하는 명령어는?
4. 입력 모드에서 현재 위치에서 현재 줄의 맨 앞으로 커서를 위치시키려면 어떤 단축키를 사용하나요?
5. 다음 중 vi(vim)의 명령 모드에서 입력 모드로 전환하는 키가 아닌 것은? : a, o, i, y

# 정답
# 1. i
# 2. A
# 3. a
# 4. I
# 5. y
```
> 입력모드에서 주로 쓰이는 키
```bash
i : 현재 커서 위치부터 입력
I : 현캐 커서가 있는 행의 제일 앞에서 입력
a : 현재 커서 다음 글자부터 입력
A : 현재 커서가 있는 행의 제일 뒤에서 입력
o : 커서가 있는 행의 다음 행으로 입력
O : 커서가 있는 행의 이전 행으로 입력
s : 현재 커서의 한 글자 지우고 입력
S : 현캐 커서의 행을 지우고 입력
```

```bash:vi 편집기 - 라인모드
1. 라인 모드에서 행번호를 보이게 하는 명령어는?
2. 라인 모드에서 파일을 저장하는 명령어는?
3. 라인 모드에서 다른 파일을 불러오는 명령어는?
4. 라안 모드에서 검색어의 하이라이트를 끄는 명령어는?
5. vi(vim)에서 현재 파일의 가장 마지막 줄로 커서를 이동하고자 한다. 현재 명령모드일 때 어떤 내용을 입력해야 하는가?

# 정답
# 1. :set number
# 2. :w
# 3. :e [파일명]
# 4. :noh
# 5. :$
```
> 라인모드에서 주로 쓰이는 키
```bash
:set number : 행번호 보이기
:set nonumber : 행번호 가리기
:n : 지정된 행으로 커서 이동
:$ : 파일의 끝 행으로 커서 이동
:w : 저장하기, vi가 종료되지 않음
:w name : 파일이 지정된 이름으로 저장하되, 기존 이름이 있을 경우 열린 문서는 저장되지 않고 새 파일이 생긴다
:q : 종료하기, 권한이 없거나 저장되지 않은 수정사항이 있으면 종료되지 않을 수 있다
:q! : 강제 종료
:wq : 저장하고 종료하기
:e name : 다른 파일 불러오기
:e! name : 저장하지 않고 다른 파일 불러오기, e!만 쓰면 자신의 파일을 다시 불러옴
:noh : 검색어의 하이라이트를 끈다(/keyword 또는 ?keyword의 하이라이트)
:(%)s/pattern/문자열/(gc) : 문서에서 패턴을 찾아 다른 문자열로 바꾸거나 수정하거나를 진행한다
```


# 쉘(SHELL)
- 쉘은 운영체제와 사용자 사이의 인터페이스로서 사용자가 커널에 쉽게 명령을 내릴 수 있도록 해준다
- 쉘의 주요 기능은 다음과 같다
    - 명령어 실행 : 사용자가 입력한 명령어 실행
    - 시작 파일 : 로그인할 때 설정 파일을 읽어 사용자의 환경을 설정

## 쉘의 종류와 쉘 변경
1. Bourne Shell(sh) : 1977, 최초의 쉘, 대부분의 리눅스에 설치(/bin/sh)
2. C Shell(csh) : 1978, 명령어 히스토리, 작업제어 등을 제공. 쉘 스크립트 문법이 C 언어(/bin/csh)
3. TC Shell(tcsh) : 1981, csh의 확장(/bin/tcsh)
4. Korn Shell(ksh) : 1983, 명령어 히스토리, 명령어 별칭(Alias), 작업 제어, 명령행 편집 기능 추가(/bin/ksh)
5. Bourne-again Shell(bash) : 1989, csh와 ksh의 장점을 결합, 가장 많이 사용하는 쉘(/bin/bash)
6. Z Shell(zsh) : 1990, 확장형 본쉘, bash와 호환, 디렉토리 히스토리, 각종 플러그인 제공(/bin/zsh)
```bash
    사용할 수 있는(설치 된 쉘 확인) : cat /etc/shells 또는 chsh -l
    현재 사용 쉘 확인 : echo $SHELL
    일시적 변경 : /etc/shells에 있는 쉘 이름을 입력하여 변경, 원래 쉘로 변경하려면 exit
    기본 쉘 변경(주의할 것)
        - 기본 쉘 확인 : cat /etc/passwd | grep 본인 아이디
        - 기본 쉘 변경 : chsh -l 명령어로 리스트 확인 후 chsh -s 바꿀 쉘 이름
```

```bash:쉘 종류와 쉘 변경
1. 쉘의 역할은 사용자가 ( a ) 에게 쉽게 명령을 내릴 수 있도록 한다. a는 무엇인가?
2. 쉘의 종류 중 하나로서 가장 많이 사용하는 쉘은?
3. 사용할 수 있는(설치 된) 쉘을 확인하는 명령어는?
4. 일시적으로 쉘을 변경하는 명령어는?
5. 기본 쉘을 확인하는 명령어와 변경하는 명령어를 입력하라

# 정답
# 1. a : 커널
# 2. Bourne-again Shell(bash)
# 3. cat /etc/shells 또는 chsh -l
# 4. (/etc/shells에 있는) 쉘 이름을 입력하여 변경 (탈출 시 exit)
# 5. 쉘 확인 - cat /etc/passwd | grep 본인아이디
#    쉘 변경 - chsh -s 쉘 이름
```

## Login Shell, Non-Login Shell
- 아이디와 비밀번호로 로그인 했다면 Login Shell
- GUI 모드에서 로그인 후 터미널을 열었다면 Non-Login Shell
    - 쉘 변경 명령어로 실행되었다면 Non-Login Shell
> 이 둘은 환경 설정이 다르며 일부 명령어 동작에 약간의 차이가 있음

```bash:Login Shell과 Non-Login Shell
1. GUI 모드에서 로그인 후 터미널을 열었다면 어떤 로그인 쉘을 이용한 것인가?
2. 아이디와 비밀번호로 로그인 했다면 어떤 로그인 쉘을 이용한 것인가?
3. 쉘 변경 명령어로 실행되었다면 어떤 로그인 쉘을 이용한 것인가?

# 정답
# 1. Non-Login Shell
# 2. Login Shell
# 3. Non-Login Shell
```

## Interactive Shell, Non-Interactive Shell
- Interactive Shell : 사용자가 대화형으로 명령을 입력하고 결과를 받는 것
    - 터미널을 통한 명령어를 실행하는 구조
- Non-interactive Shell : 쉘 스크립트를 통해 실행되는 쉘

```bash:Interactive Shell 과 Non-Interactive Shell
1. 사용자가 대화형으로 명령을 입력하고 결과를 받는 쉘로, 터미널로 통한 명령어를 실행하는 구조인 쉘은?
2. 쉘 스크립트를 통해 실행되는 쉘은?


# 정답
# 1. Interactive Shell
# 2. Non-Interactive Shell
```


# ✅환경변수
- 쉘이 명령을 수행하는데 사용하는 각종 기본 변수들
`변수이름=값`
- 위의 형태를 가지며 변수 이름과 = 과 값 사이에 ***공백이 없어야한다***
- 값을 읽을 떄는 이름 앞에 $를 붙이고 변경할 때는 이름만 쓴다

## 관련 명령어 모음
- env                : 전역 환경 변수 출력
- echo $변수명        : 해당 환경 변수의 값을 출력
- export 변수이름=값  : 전역 환경 변수 값 추가 또는 변경
> 현재 세션을 종료하면(터미널을 끄거나 로그아웃) 값 변경 내용이 사라진다

- $변수이름 // 현재 설정된 값을 불러오기(Read)
- 변수이름=값 // 환경 변수를 수정, 실행 동작

```bash:환경변수 예제1
.bashrc 파일에 HELLO 라는 변수명으로 해당 변수를 호출할 때 "Hello World!"를 표출하도록 만들어라 (source .bashrc 로 리로드 작업을 진행할 것)

# 정답
# vi .bashrc
# export HELLO="Hello World"
# :wq
# source .bashrc
# echo $HELLO
```

## 환경변수의 주요 항목

### 시스템 정보
- HOSTNAME : 시스템의 호스트명
- PATH     : 실행 파일이 위치한 디렉토리들의 정보
- LANG     : 쉘의 언어

### 시스템 설정
- /etc/profile     : 시스템 전역 설정
- /etc/profile.d/* : 사용자가 로그인 할 때 이 디렉토리 안의 모든 스크립트를 실행한다
- /etc/bashrc      : 비로그인쉘을 실행할 때의 설정

### 쉘 정보
- PS1      : 기본 프롬프트
- SHELL    : 사용자의 쉘
- HISTFILE : 사용자의 명령어 history가 저장 된 파일 

### 사용자
- UID  : 사용자의 uid(/etc/passwd 에서 볼 수 있는 숫자 아이디)
- USER : 사용자의 계정 이름
- HOME : 사용자의 홈 디렉토리

### 사용자 설정
- ~/.bash_profile(~/.bash_login) : 사용자가 시스템에 로그인할 때마다 실행된다
    - 수정 후 source .bash_profile 명령어로 즉시 적용 가능하다
- ~/.profile                     : 사용자가 로그인할 때마다 실행된다
    - 주로 bash 와 직접 관련이 없는 내용들을 기재한다
- ~/.bashrc                      : 비로그인에서 실행(터미널을 열 때마다 실행된다)
    - Alias 등을 설정한다
- ~/.bash_logout                 : 로그아웃할 때마다 실행된다

```bash:환경변수 예제2
1. 시스템 전역 설정과 관련된 환경변수는?
2. 사용자가 로그인할 때마다 실행되며, 주로 bash와 직접 관련이 없는 내용들을 기재하는 환경변수는?
3. 시스템의 호스트명으로 쓰이는 환경변수는?
4. 사용자의 홈 디렉토리를 가리키는 환경변수는?
5. 사용자의 쉘을 저장하는 환경변수는?
6. 비로그인을 실행할 때의 설정하는 환경 변수는?
7. 사용자의 uid를 담고 있는 환경 변수는?
8. 기본 프롬프트를 갖는 환경 변수는?
9. 쉘의 언어를 저장하는 환경 변수는?
10. 사용자가 로그인할 때 디렉토리 안의 모든 스크립트를 실행하는 환경변수는?
11. 사용자의 계정 이름을 담고있는 환경변수는?
12. 로그아웃 할 때마다 실행되는 환경변수는?
13. 비로그인쉘에서 실행되며 터미널을 열 때마다 실행되고 Alias 등을 설정하는 환경변수는?
14. 실행 파일이 위치한 디렉토리들의 정보를 갖고 있는 환경 변수는?
15. 사용자의 명령어 history가 저장된 환경 변수는?
16. 사용자가 시스템에 로그인할 때마다 실행되며 수정 후 source ( a ) 명령어로 즉시 적용가능한 환경변수는?
17. 터미널을 열 때마다 적용되는 각 사용자의 개별 설정이 저장된 파일은?
18. 다음 환경변수 중 이름과 의미가 다른 것은?
  a. PATH - 실행파일을 찾는 경로들
  b. UID - 사용자의 로그인용 계정 이름
  c. HOME - 사용자의 홈 디렉토리
  d. SHELL - 사용자의 쉘


# 정답
# 1. /etc/profile
# 2. ~/.profile
# 3. HOSTNAME
# 4. HOME
# 5. SHELL
# 6. /etc/bashrc
# 7. UID
# 8. PS1
# 9. LANG
# 10. /etc/profile.d/*
# 11. USER
# 12. ~/.bash_logout
# 13. ~/.bashrc
# 14. PATH
# 15. HISTFILE
# 16. ~/.bash_profile(~/.bash_login)
# 17. ~/.bashrc
# 18. b
```

## 로그인 ~ 로그아웃까지의 과정
> 전역 설정을 먼저 진행한 다음 각 사용자의 추가 설정이 진행되는 과정을 거침
1. 로그인
`.bash_profile`
- 로그인 시 해당 파일에 접근
- 시스템 설정의 /etc/profile에 있는 로그인 정보를 로딩함
`.profile`
- 사용자 설정 파일로, 있을 수도 있으며 없을 수도 있음

2. 터미널 열기
`.bashrc`

3. 로그아웃
`.bash_logout`

```bash:로그인 ~ 로그아웃의 과정
- 로그인부터 로그아웃의 과정까지 사용되는 환경변수들이다. 순서에 맞게 나열하라
a. .bash_profile
b. .bash_logout
c. .bashrc
d. .profile

# 정답
# a -> d -> c -> b
```

## 쉘의 시작과 종료

### 시작
- Login Shell
    1. /etc/profile
    2. /etc/profile.d/*
    3. ~/.bash_profile
    4. ~/.profile
- Interactive Shell
    1. /etc/bashrc
    2. ~/.bashrc

### 종료
    ~/.bash_logout

```bash:쉘의 시작과 종료
1. 다음은 Login Shell 의 시작 과정 중 사용되는 환경변수들이다. 순서대로 나열하라
  a. /etc/profile.d/*
  b. ~/.profile
  c. /etc/profile
  d. ~/.bash_profile

2. Interactive Shell 의 시작과정은 먼저 ( a ) 환경변수를 읽은 뒤 ( b ) 환경 변수를 읽어 시작하게 된다

3. 쉘의 종료 시 사용하는 환경 변수는?

# 정답
# 1. c -> a -> d -> b
# 2. a) /etc/bashrc   b) ~/.bashrc
# 3. ~/.bash_logout

```


# 쉘의 부가 기능

## 기본 부가기능
- 자동 완성 : 탭키를 이용하여 자동 완성을 해준다
- 히스토리 : 사용자가 입력한 명령어 보관
    - 파일 위치        : echo $HISTFILE 로 확인
    - 명령어 리스트    : history
    - 직전 명령어 실행 : !!
    - 특정 명령어 실행 : !번호
    - 히스토리 삭제    : history -c

```bash:쉘의 기본 부가기능
1. 쉘의 기본 부가기능으로 자동 완성을 하기 위해 ( a ) 키를 이용한다
2. 쉘의 기본 부가기능으로 사용자가 입력한 명령어 보관하는 곳은?
3. 사용자가 입력한 명령어를 보관하는 위치를 확인할 때 사용하는 명령어는?
4. 사용자가 입력한 직전 명령어를 다시 실행하고자 할 때 사용하는 명령어는?
5. 사용자가 사용한 명령어 리스트를 확인하고 싶을 때 사용하는 명령어는?
6. 사용자가 사용한 명령어 리스트내에서 특정 명령어 번호를 통해 실행하는 명령어는?
7. 사용자가 입력한 명령어들의 리스트를 삭제하기 위해 사용하는 명령어는?

# 정답
# 1. 탭(Tab)
# 2. 히스토리(History)
# 3. echo $HISTFILE
# 4. !!
# 5. history
# 6. !번호
# 7. history -c

```

## 명령어 별칭(Alias)
- 복잡하거나 자주 사용하는 명령어는 별칭을 정해두고 사용할 수 있다
`생성 : alias 별칭=명령어`
`제거 : unalias 별칭`
- 별칭은 현재 접속 access 에서만 가능하여, 새 터미널을 열 경우엔 사라짐
- 따라서 계속 사용하기 위해서는 `~/.bashrc` 에 해당 내용을 저장하면 된다
```bash:명령어 별칭
1. 복잡하거나 자주 사용하는 명령어를 별칭으로 사용할 때 선언하는 명령어는?
2. 해당 별칭을 삭제하는 명령어는?
3. 다음 명령어를 hello 라는 명령어로 줄여 사용하고 싶다. 해당 명령어를 적어라
  - 명령어 : echo Hello

# 정답
# 1. Alias
# 2. unalias
# 3. alias hello="echo Hello"

```

## 명령어 치환(Command Substitution)
- 명령어의 실행 결과를 다른 명령어로 바로 넘길 수 있는 기능
> 백틱(`)으로 명령어를 감싸거나 $() 로 명령어를 감싼다
```bash:명령어 치환
1. 명령어의 실행 결과를 다른 명령어로 바로 넘길 수 있는 기능을 사용하는 명령어 치환법 2가지를 설명하시오.
2. 사용자 아이디를 이름으로 가지는 빈 파일를 명령어 치환을 통해 생성하라

# 정답
# 1. 1) 백틱(`)으로 명령어 감싸기,  2) $() 로 명령어로 감싸기
# 2. touch `whoami` 또는 touch $(whoami)
```

## 작업 제어(Job Control)
- 작업이란?
  - 사용자가 실행하고자 하는 일
  - 파이프를 사용하거나 명령어 그룹일 경우 하나의 작업에 두 개 이상의 명령어가 포함될 수 있다
  - `ls | sort` -> 2개의 명령어, 1개의 작업
  - `(sleep 10; echo done)` -> 2개의 명령어, 1개의 작업
- 작업 제어란?
  - 작업을 종료하거나 멈춘 뒤 다시 시작하게 하는 등의 일을 말한다

### 작업 제어의 종류
- 전면 처리(보통 처리하는 작업 과정)
  - 입력된 명령어를 실행하고 실행이 종료되면 다음 명령을 받는다
  - 전면 실행 중인 작업은 터미널을 통해 사용자로부터 입력을 받을 수 있다
- 후면 처리(시간이 오래 걸리는 작업 - 파일 다운로드 등)
  - 명령어 다음에 `&`를 붙이면 후면 처리 된다
  - 명령어를 입력하면 후면에서 실행하고 동시에 전면에서 다른 작업을 입력 받는다
  - 사용자의 입력이 필요 없고 시간이 오래 걸리는 일을 처리하는데에 사용한다

> 후면에서 실행되고 있는 작업 리스트를 확인
`jobs [%작업번호]`
- 작업 번호를 생략하면 전체 리스트 조회
- 작업 번호 뒤 + 는 가장 최근 프로세스
- -는 가장 직전 프로세스
`fg %작업번호`
- 작업 번호를 이용해 전면으로 전환
```bash:작업 제어 예제1
1. 후면에서 실행되고 있는 전체 작업 리스트를 확인할 때 사용하는 명령어는?
2. 해당 작업 번호를 이용하여 전면으로 전환하는 명령어는? (작업번호가 1번이라고 가정)
3. 명령어를 후면으로 실행하고 싶을 때 명령어 끝에 적는 것은?

# 정답
# 1. jobs
# 2. fg %1
# 3. &
```

> 실행 종료
- 전면 작업의 경우 : `Ctrl + c`
- 후면 작업의 경우 : `kill %작업번호`

> 실행 중단
- 전면 작업 : `Ctrl + z`

> 중단 된 프로세스를 다시 실행하기
- `fg %작업번호` 또는 `bg %작업번호`
  - 중지된 작업을 전면 또는 후면에서 다시 실행하도록 함

### 활용 방법
- 전면으로 처리하고 있는 작업이 너무 오래 걸린다면 실행 중단(Ctrl + z)한다
- 이후 해당 작업을 후면 처리로 전환(bg %작업번호)하고 그 작업을 jobs 를 통해 확인한다

```bash:작업 제어 예제2
1. 전면과 후면 작업에서의 실행 종료 단축키(명령어)를 각각 입력하시오
2. 전면 작업의 실행 중단하는 단축키는?
3. 중단 된 프로세스를 전면, 후면에서 실행하도록 하는 명령어는?
4. 다음과 같이 후면에서 실행 중인 명령어들이 있을 때 sleep 100 명령어를 전면으로 불러오는 명령어를 적어라
 - [1] running sleep 200
 - [2] running sleep 50
 - [3] -running sleep 100
 - [4] +running sleep 300


# 정답
# 1. 전면) Ctrl + c, 후면) kill %작업번호
# 2. Ctrl + z
# 3. 전면) fg %작업번호,  후면) bg %작업번호
# 4. Ctrl + z -> fg %3

```

## 프롬프트 제어
- 프롬프트(Prompt) : 사용자에게 명령어를 입력할 수 있는 환경을 제공하는 문자열
> 현재 프롬프트 확인 `echo $PS1`
`[\u@\h \W]\$`
  - \u : username
  - @\h : host의 첫 마침표까지의 이름
  - \W : 현재 작업 디렉토리의 절대 경로 중 마지막 디렉토리
  - \$ : 관리자(uid 0)면 #, 나머지는 $로 표기
  - \t : 24시간 표기로 시간
  - \T : 12시간 표기로 시간